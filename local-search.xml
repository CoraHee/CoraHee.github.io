<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>L23.合并k个有序链表</title>
    <link href="/2025/03/17/L23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/03/17/L23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">力扣：23. 合并k个升序链表</a></p><p>难度：🔴</p><p>这题是合并两个有序链表的扩展，很简单的思路：创建一个新的链表，头节点为<code>dummy</code>，此时比较这<code>k</code>个链表的<code>head</code>，谁的值最小，那么谁就接到这个新链表后面，该节点的下一个节点成为它所在链表的新<code>head</code>（感觉像是在玩分类收纳小游戏）。</p><p>为了快速得到这<code>k</code>个<code>head</code>节点中，值最小的节点，可以考虑把它们放进一个最小堆，就可以得到值最小的那一个节点。</p><p>解法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a, b) -&gt; (a.val - b.val));<br>        <span class="hljs-keyword">for</span>(ListNode node:lists)&#123;<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">null</span>)&#123;<br>                pq.add(node);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">curNode</span> <span class="hljs-operator">=</span> pq.poll();<br>            p.next = curNode;<br>            p = p.next;<br><br>            <span class="hljs-keyword">if</span>(curNode.next != <span class="hljs-literal">null</span>)&#123;<br>                pq.add(curNode.next);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里可以注意到创建了最小堆的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a, b) -&gt; (a.val - b.val));<br></code></pre></td></tr></table></figure><p>其中，**<code>(a, b)-&gt;(a.val - b.val)</code>**是一个 Lambda 表达式，用于定义优先队列的比较器（<code>Comparator</code>）。比较器的作用是定义元素之间的优先级顺序。在这个 Lambda 表达式中，<code>a</code> 和 <code>b</code> 是两个 <code>ListNode</code> 对象，<code>a.val - b.val</code> 表示根据 <code>ListNode</code> 的 <code>val</code> 属性值进行比较。如果 <code>a.val - b.val</code> 的结果小于 0，则表示 <code>a</code> 的优先级高于 <code>b</code>；如果结果大于 0，则表示 <code>b</code> 的优先级高于 <code>a</code>；如果结果等于 0，则表示 <code>a</code> 和 <code>b</code> 的优先级相同。</p><a href="/2025/03/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/" title="Lambda表达式用法">Lambda表达式用法</a><p>最后感谢：<a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary-2/#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">labuladong</a>！</p>]]></content>
    
    
    <categories>
      
      <category>狂刷LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式用法</title>
    <link href="/2025/03/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <url>/2025/03/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda 表达式是 Java 8 引入的一个重要特性，它允许你将函数作为参数传递给方法，或者将代码像数据一样传递。Lambda 表达式可以让代码更加简洁、易读。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>Lambda 表达式的基本语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression<br><span class="hljs-comment">// 或:</span><br>(parameters) -&gt; &#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>parameters</code>**：参数列表，可以为空，也可以包含一个或多个参数。如果只有一个参数，括号可以省略。</li><li>**<code>-&gt;</code>**：箭头符号，用于分隔参数列表和 Lambda 表达式的主体。</li><li>**<code>expression</code>**：表达式，如果 Lambda 表达式只包含一个表达式，不需要使用大括号，并且表达式的结果会作为 Lambda 表达式的返回值。</li><li>**<code>&#123; statements; &#125;</code>**：语句块，如果 Lambda 表达式包含多个语句，需要使用大括号将语句括起来，并且可以使用 <code>return</code> 语句返回值。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>Lambda 表达式通常用于函数式接口。函数式接口是指只包含一个抽象方法的接口。Java 中有许多内置的函数式接口，如 <code>Comparator</code>、<code>Runnable</code>、<code>Consumer</code> 等。下面通过不同的示例来介绍 Lambda 表达式的使用。</p><h2 id="1-使用-Lambda-表达式实现-Runnable-接口"><a href="#1-使用-Lambda-表达式实现-Runnable-接口" class="headerlink" title="1. 使用 Lambda 表达式实现 Runnable 接口"></a>1. 使用 Lambda 表达式实现 <code>Runnable</code> 接口</h2><p><code>Runnable</code> 接口是一个函数式接口，它只包含一个抽象方法 <code>run()</code>。可以使用 Lambda 表达式来实现 <code>Runnable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaRunnableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用 Lambda 表达式实现 Runnable 接口</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Task is running: &quot;</span> + i);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 创建一个线程并启动</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，使用 Lambda 表达式 <code>() -&gt; &#123; ... &#125;</code> 实现了 <code>Runnable</code> 接口的 <code>run()</code> 方法。</p><hr><p>‼️ 在 Java 中，Lambda 表达式通过<strong>目标类型推断</strong>和<strong>函数式接口</strong>的特性，<strong>隐式地</strong>实现了 <code>Runnable</code> 接口的 <code>run()</code> 方法。</p><h4 id="（一）核心原理：函数式接口与目标类型推断"><a href="#（一）核心原理：函数式接口与目标类型推断" class="headerlink" title="（一）核心原理：函数式接口与目标类型推断"></a>（一）核心原理：函数式接口与目标类型推断</h4><h5 id="1-Runnable-是函数式接口"><a href="#1-Runnable-是函数式接口" class="headerlink" title="1. Runnable 是函数式接口"></a>1. <code>Runnable</code> 是函数式接口</h5><p><code>Runnable</code> 接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>@FunctionalInterface</code></strong> 注解标记该接口为函数式接口，即<strong>仅含一个抽象方法</strong>（此处为 <code>run()</code>）。</li><li>函数式接口的设计目的是为 Lambda 表达式提供目标类型。</li></ul><h5 id="2-Lambda-表达式的类型匹配规则"><a href="#2-Lambda-表达式的类型匹配规则" class="headerlink" title="2. Lambda 表达式的类型匹配规则"></a>2. Lambda 表达式的类型匹配规则</h5><p>当 Lambda 表达式出现在函数式接口的上下文（如变量声明、方法参数）时，<strong>编译器会自动将其匹配到接口的唯一抽象方法</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123; <span class="hljs-comment">/* 代码 */</span> &#125;;<br></code></pre></td></tr></table></figure><ul><li><strong><code>()</code></strong> 匹配 <code>run()</code> 的无参数签名。</li><li><strong><code>&#123; /\* 代码 \*/ &#125;</code></strong> 匹配 <code>run()</code> 的方法体。</li></ul><h4 id="（二）隐式实现的底层机制"><a href="#（二）隐式实现的底层机制" class="headerlink" title="（二）隐式实现的底层机制"></a>（二）隐式实现的底层机制</h4><h5 id="1-匿名内部类对比（传统写法）"><a href="#1-匿名内部类对比（传统写法）" class="headerlink" title="1. 匿名内部类对比（传统写法）"></a>1. 匿名内部类对比（传统写法）</h5><p>在 Java 8 之前，实现 <code>Runnable</code> 需要显式写匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 代码</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Lambda 表达式本质上是匿名内部类的<strong>语法糖</strong>，两者在编译后生成的字节码功能相同，但 Lambda 更简洁。</p><h5 id="2-编译器的转换过程"><a href="#2-编译器的转换过程" class="headerlink" title="2. 编译器的转换过程"></a>2. 编译器的转换过程</h5><p>当编译器遇到 <code>() -&gt; &#123; ... &#125;</code> 时：</p><ol><li>检查目标类型是否为函数式接口（此处为 <code>Runnable</code>）。</li><li>将 Lambda 表达式的参数列表和方法体映射到接口的抽象方法（<code>run()</code>）。</li><li>生成等价的匿名内部类实现。</li></ol><h4 id="（三）代码示例对比"><a href="#（三）代码示例对比" class="headerlink" title="（三）代码示例对比"></a>（三）代码示例对比</h4><h5 id="1-显式实现（匿名内部类）"><a href="#1-显式实现（匿名内部类）" class="headerlink" title="1. 显式实现（匿名内部类）"></a>1. 显式实现（匿名内部类）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Running via anonymous class&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-隐式实现（Lambda-表达式）"><a href="#2-隐式实现（Lambda-表达式）" class="headerlink" title="2. 隐式实现（Lambda 表达式）"></a>2. 隐式实现（Lambda 表达式）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Running via Lambda&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-等价性验证"><a href="#3-等价性验证" class="headerlink" title="3. 等价性验证"></a>3. 等价性验证</h5><p>两者执行效果完全相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">task.run(); <span class="hljs-comment">// 输出 &quot;Running via Lambda&quot; 或 &quot;Running via anonymous class&quot;</span><br></code></pre></td></tr></table></figure><h4 id="（四）为什么不需要显式写-run-？"><a href="#（四）为什么不需要显式写-run-？" class="headerlink" title="（四）为什么不需要显式写 run()？"></a>（四）为什么不需要显式写 <code>run()</code>？</h4><h5 id="1-函数式接口的约束"><a href="#1-函数式接口的约束" class="headerlink" title="1. 函数式接口的约束"></a>1. 函数式接口的约束</h5><p>由于 <code>Runnable</code> 只有一个抽象方法 <code>run()</code>，编译器可以<strong>唯一确定</strong> Lambda 表达式应匹配该方法。</p><h5 id="2-类型推断的作用"><a href="#2-类型推断的作用" class="headerlink" title="2. 类型推断的作用"></a>2. 类型推断的作用</h5><p>编译器通过上下文（变量类型为 <code>Runnable</code>）推断出 Lambda 必须实现 <code>run()</code> 方法，无需显式声明方法名。</p><h4 id="（五）常见误区澄清"><a href="#（五）常见误区澄清" class="headerlink" title="（五）常见误区澄清"></a>（五）常见误区澄清</h4><h5 id="误区-1：Lambda-是匿名类的替代"><a href="#误区-1：Lambda-是匿名类的替代" class="headerlink" title="误区 1：Lambda 是匿名类的替代"></a>误区 1：Lambda 是匿名类的替代</h5><p>正确理解：Lambda 是函数式接口的<strong>更简洁实现方式</strong>，底层仍通过匿名类实现，但语法更紧凑。</p><h5 id="误区-2：Lambda-必须显式指定方法名"><a href="#误区-2：Lambda-必须显式指定方法名" class="headerlink" title="误区 2：Lambda 必须显式指定方法名"></a>误区 2：Lambda 必须显式指定方法名</h5><p>正确理解：Lambda 通过目标类型推断自动匹配接口的抽象方法，无需显式写方法名。</p><hr><h2 id="2-使用-Lambda-表达式实现-Comparator-接口"><a href="#2-使用-Lambda-表达式实现-Comparator-接口" class="headerlink" title="2. 使用 Lambda 表达式实现 Comparator 接口"></a>2. 使用 Lambda 表达式实现 <code>Comparator</code> 接口</h2><p><code>Comparator</code> 接口是一个函数式接口，它只包含一个抽象方法 <code>compare(T o1, T o2)</code>。可以使用 Lambda 表达式来实现 <code>Comparator</code> 接口，用于对集合进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaComparatorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个包含 Person 对象的列表</span><br>        List&lt;Person&gt; people = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>));<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>));<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">30</span>));<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式实现 Comparator 接口</span><br>        Comparator&lt;Person&gt; ageComparator = (p1, p2) -&gt; p1.getAge() - p2.getAge();<br><br>        <span class="hljs-comment">// 对列表进行排序</span><br>        Collections.sort(people, ageComparator);<br><br>        <span class="hljs-comment">// 输出排序后的列表</span><br>        <span class="hljs-keyword">for</span> (Person person : people) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，使用 Lambda 表达式 <code>(p1, p2) -&gt; p1.getAge() - p2.getAge()</code> 实现了 <code>Comparator&lt;Person&gt;</code> 接口的 <code>compare()</code> 方法，用于按照年龄对 <code>Person</code> 对象进行排序。</p><h2 id="3-使用-Lambda-表达式处理集合"><a href="#3-使用-Lambda-表达式处理集合" class="headerlink" title="3. 使用 Lambda 表达式处理集合"></a>3. 使用 Lambda 表达式处理集合</h2><p>Java 8 引入了 Stream API，它提供了许多方法来处理集合。可以使用 Lambda 表达式来定义这些方法的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个包含整数的列表</span><br>        List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        numbers.add(<span class="hljs-number">1</span>);<br>        numbers.add(<span class="hljs-number">2</span>);<br>        numbers.add(<span class="hljs-number">3</span>);<br>        numbers.add(<span class="hljs-number">4</span>);<br>        numbers.add(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用 Lambda 表达式过滤出偶数并打印</span><br>        numbers.stream()<br>               .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，使用 Lambda 表达式 <code>n -&gt; n % 2 == 0</code> 作为 <code>filter()</code> 方法的参数，用于过滤出列表中的偶数。然后使用方法引用 <code>System.out::println</code> 作为 <code>forEach()</code> 方法的参数，用于打印过滤后的元素。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lambda 表达式的使用步骤如下：</p><ol><li>确定需要实现的函数式接口。</li><li>根据函数式接口的抽象方法定义 Lambda 表达式的参数列表和返回值。</li><li>使用 Lambda 表达式实现函数式接口的抽象方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础语法</tag>
      
      <tag>力扣总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/12/hello-world/"/>
    <url>/2025/03/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
